//Биюлиотеку надо скачать из интернета
#include <TimerOne.h>

unsigned long Time = 0; //Время предыдущего изменения переменной i
int servo = 8; //pin на который подключенн сервопрвод 
float i = 0; //Переменная определяющая угол поворота сервопривода (i = 1 означает поворот в 10 градусов)
bool turn = true; //Порядок обхода

//Функция для прерывания
void func(){
  digitalWrite(servo, HIGH);
  //Задержка принимает значение от 540 до 2300 мкс
  //В обычных серво должна принимать от 1000 до 2000 мкс
  //i - от 0 до 18 (по логике программы)
  delayMicroseconds(i*(2300-540)/18.0 + 540);
  digitalWrite(servo, LOW);  
}
  //Каждые 20 мс на сервопривод должен поступать импульс,
  //Сообщающий на какой угол повернуться
  //В обычных серво это от 1 мс - 0 градусов, до 2 мс - 180 градусов. Сооветственно 1.5 мс - 90 градусов
  //В нашем случае от 540 - 0 до 2300 мкс - 180 градусов
  //Сервопривод подключается так:
  //     коричневый - земля
  //     красный - 5 В
  //     желтый(рыжий) - digital pin

void setup() {
  // Таймер обнуляется каждые n микросекунд
  Timer1.initialize(20000); //20000 мкс = 20 мс 

  // Обяъявляем о прерывании по обнулению таймера
  Timer1.attachInterrupt(func); //void func(){} - ф-ия вызываемая по прерыванию

  //ПинМод :)
  pinMode(servo, OUTPUT);
}

void loop() {
  // Каждые 500 милисекунд изменяем значение i
  // Каждые 0,5 секунды поворачиваем сервопривод на 10 градусов
  // После того как серво повернется на 180 градусов, поворачиваем в обратном порядке
  if(millis() - Time > 500){
  //turn определяет порядок обхода, прямой или обратный
    if(turn){
      i += 1;
        if(i >= 18){
          turn = !turn;
      }
    }
    else{
      i -= 1;
      if(i <= 0){
        turn = !turn;
      }
    }    
    Time = millis();
  }
}